sir dude — here’s a single drop-in file: **`spec_tile_expansion.rs`**. Copy it as-is.

```rust
//! nobonk v0.2 — Tile Expansion Spec
//!
//! This file *extends* the base nobonk spec with tilemap support, DDA
//! ray/sweep, and resolution hints (safe last position / unembed flags).
//! It defines **types + trait signatures + semantics** only (no impls).
//!
//! Summary:
//! - Attach/update/detach tilemaps stored as a dense 0/1 grid (no per-tile colliders).
//! - Fast-path DDA for raycasts and sweeps (AABB/circle via Minkowski).
//! - Unified queries/raycast return hits against *colliders and tiles*.
//! - Events can reference a collider or a specific tile cell.
//! - Overlap/Sweep hits include `ResolutionHint { safe_pos, start_embedded, fully_embedded }`.
//!
//! Conventions used below:
//! - World-space origin and units match the base spec.
//! - Tilemap `origin` is **top-left** of cell (i=0,j=0). `cell` is square size.
//! - Mutual-consent masking applies between collider masks and tilemap mask.
//!
//! This file assumes the base spec items exist (LayerMask, ColKey, FrameId,
//! EventKind, Overlap, SweepHit, WorldConfig, WorldStats, WorldTiming, etc.).

use glam::{UVec2, Vec2};

// -----------------------------------------------------------------------------
// New / Updated Types
// -----------------------------------------------------------------------------

/// Opaque handle to a registered tilemap layer.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct TileMapRef(pub u32);

/// Identifies a specific tile cell within a map.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct TileRef {
    pub map: TileMapRef,
    pub cell_xy: UVec2, // (x,y) in 0..(width-1, height-1)
}

/// Description of a tilemap to attach to the world.
/// `solids` is a dense row-major buffer (len = width*height), nonzero = solid.
#[derive(Clone, Debug)]
pub struct TileMapDesc<'a> {
    pub origin: Vec2,       // world-space top-left of (0,0) cell
    pub cell: f32,          // tile size (square)
    pub width: u32,
    pub height: u32,
    pub solids: &'a [u8],   // 0/1 bytes; impl may copy or borrow internally
    pub mask: LayerMask,    // participates in mutual-consent checks
    pub user_key: Option<ColKey>, // echoed in events/queries for tiles
}

/// Resolution hint attached to hits (tiles & non-tiles).
#[derive(Copy, Clone, Debug, Default)]
pub struct ResolutionHint {
    /// A recommended non-penetrating center position for A, if available.
    /// Sweeps: `p0 + v*(toi - eps)` where `eps = max(tile_eps, 1e-6)`.
    /// Overlaps: axis-aligned minimal push-out if found.
    pub safe_pos: Option<Vec2>,
    /// True if A started inside B (embedded at t=0).
    pub start_embedded: bool,
    /// True if A remained embedded for the whole [0,1] motion (no valid TOI
    /// and no successful push-out along primary axes).
    pub fully_embedded: bool,
}

/// Reference to an event participant (collider or tile).
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BodyRef {
    Collider(FrameId),
    Tile(TileRef),
}

// --- Base-spec updates (types must exist already) ---------------------------

/// Overlap contact result (discrete). Extended with `hint`.
#[derive(Copy, Clone, Debug)]
pub struct Overlap {
    pub normal: Vec2,   // approx separating normal; may be (0,0) in degenerate cases
    pub depth: f32,     // ≥ 0
    pub contact: Vec2,  // representative contact point
    pub hint: ResolutionHint, // NEW
}

/// Sweep (time-of-impact) result for continuous detection. Extended with `hint`.
#[derive(Copy, Clone, Debug)]
pub struct SweepHit {
    pub toi: f32,       // ∈ [0,1]
    pub normal: Vec2,   // points from B into A at impact
    pub contact: Vec2,  // representative impact/contact point
    pub hint: ResolutionHint, // NEW
}

/// Event emitted by the world. Uses BodyRef instead of raw FrameId.
#[derive(Copy, Clone, Debug)]
pub struct Event {
    pub kind: EventKind,      // Overlap | Sweep
    pub a: BodyRef,           // Collider(_) or Tile(_)
    pub b: BodyRef,           // Collider(_) or Tile(_)
    pub a_key: Option<ColKey>,// collider.user_key or tilemap.user_key
    pub b_key: Option<ColKey>,
    pub overlap: Option<Overlap>,
    pub sweep: Option<SweepHit>,
}

// --- World config additions -------------------------------------------------

/// World-level configuration (base fields + these).
#[derive(Clone, Debug)]
pub struct WorldConfig {
    // base fields (cell_size, dt, tighten_swept_aabb, enable_*_events, max_events, enable_timing)
    pub cell_size: f32,
    pub dt: f32,
    pub tighten_swept_aabb: bool,
    pub enable_overlap_events: bool,
    pub enable_sweep_events: bool,
    pub max_events: usize,
    pub enable_timing: bool,

    /// Epsilon used when computing `hint.safe_pos` for sweeps.
    /// Default recommendation: `1e-4 * cell_size`.
    pub tile_eps: f32,

    /// If true (recommended default), require A↔B mutual consent for all
    /// events and queries (collider-collider and collider-tile).
    pub require_mutual_consent: bool,
}

// -----------------------------------------------------------------------------
// Physics World API — Tile Extensions & Unified Queries
// -----------------------------------------------------------------------------

/// Public API contract (extends the base trait; re-listing for clarity).
pub trait PhysicsWorldApi {
    // --- Construction / frame lifecycle (from base spec) -------------------
    fn new(cfg: WorldConfig) -> Self where Self: Sized;
    fn begin_frame(&mut self);
    fn push(&mut self, desc: ColliderDesc, motion: Motion) -> FrameId;
    fn push_circle(&mut self, center: Vec2, radius: f32, vel: Vec2,
                   mask: LayerMask, user_key: Option<ColKey>) -> FrameId;
    fn push_aabb(&mut self, center: Vec2, half_extents: Vec2, vel: Vec2,
                 mask: LayerMask, user_key: Option<ColKey>) -> FrameId;
    fn push_point(&mut self, p: Vec2, vel: Vec2,
                  mask: LayerMask, user_key: Option<ColKey>) -> FrameId;
    fn end_frame(&mut self);

    // --- Events -------------------------------------------------------------
    fn generate_events(&mut self);
    fn drain_events(&mut self) -> Vec<Event>;

    // --- Collider-only queries (from base spec) ----------------------------
    fn raycast(&self, origin: Vec2, dir: Vec2, mask: LayerMask, max_t: f32)
        -> Option<(FrameId, SweepHit, Option<ColKey>)>;
    fn query_point(&self, p: Vec2, mask: LayerMask) -> Vec<(FrameId, Option<ColKey>)>;
    fn query_aabb(&self, center: Vec2, half_extents: Vec2, mask: LayerMask)
        -> Vec<(FrameId, Option<ColKey>)>;
    fn query_circle(&self, center: Vec2, radius: f32, mask: LayerMask)
        -> Vec<(FrameId, Option<ColKey>)>;

    // --- Pairwise checks (from base spec) ----------------------------------
    fn overlap_pair(&self, a: FrameId, b: FrameId) -> Option<Overlap>;
    fn sweep_pair(&self, a: FrameId, b: FrameId) -> Option<SweepHit>;
    fn overlap_by_key(&self, a: ColKey, b: ColKey) -> Option<Overlap>;
    fn sweep_by_key(&self, a: ColKey, b: ColKey) -> Option<SweepHit>;

    // --- Tilemap lifecycle --------------------------------------------------

    /// Attach a tilemap layer. Multiple tilemaps are allowed.
    /// `solids` is treated immutable except through `update_tiles`.
    fn attach_tilemap(&mut self, desc: TileMapDesc) -> TileMapRef;

    /// Update a rectangular region (x,y,w,h) of the tile buffer for `map`.
    /// `data.len()` must equal `w*h` (row-major).
    fn update_tiles(&mut self, map: TileMapRef, changed_rect: (u32,u32,u32,u32), data: &[u8]);

    /// Detach and free a tilemap.
    fn detach_tilemap(&mut self, map: TileMapRef);

    // --- Unified queries (colliders + tiles; closest or full set) ----------

    /// Raycast against colliders **and** all tilemaps; returns the closest hit.
    fn raycast_all(&self, origin: Vec2, dir: Vec2, mask: LayerMask, max_t: f32)
        -> Option<(BodyRef, SweepHit, Option<ColKey>)>;

    /// Return all bodies (collider or tile) containing the point.
    fn query_point_all(&self, p: Vec2, mask: LayerMask) -> Vec<(BodyRef, Option<ColKey>)>;

    /// Return all bodies overlapping the AABB.
    fn query_aabb_all(&self, center: Vec2, half_extents: Vec2, mask: LayerMask)
        -> Vec<(BodyRef, Option<ColKey>)>;

    /// Return all bodies overlapping the circle.
    fn query_circle_all(&self, center: Vec2, radius: f32, mask: LayerMask)
        -> Vec<(BodyRef, Option<ColKey>)>;

    // --- Tile-only fast path (for profiling / direct control) ---------------

    /// Raycast against tiles only (closest hit across all tilemaps).
    fn raycast_tiles(&self, origin: Vec2, dir: Vec2, max_t: f32, mask: LayerMask)
        -> Option<(TileRef, SweepHit, Option<ColKey>)>;

    /// Sweep AABB against tiles only (first hit).
    fn sweep_aabb_tiles(&self, center: Vec2, half_extents: Vec2, vel: Vec2, mask: LayerMask)
        -> Option<(TileRef, SweepHit, Option<ColKey>)>;

    /// Sweep circle (via Minkowski inflation) against tiles only (first hit).
    fn sweep_circle_tiles(&self, center: Vec2, radius: f32, vel: Vec2, mask: LayerMask)
        -> Option<(TileRef, SweepHit, Option<ColKey>)>;
}

// -----------------------------------------------------------------------------
// Narrowphase Additions (optional helpers for tile push-out)
// -----------------------------------------------------------------------------

pub trait NarrowphaseApi {
    // Base primitives (ray_aabb, ray_circle, line_segment_*, overlap_*, sweep_*) exist.

    /// Axis-aligned push-out of an AABB from a *solid tile cell* whose world
    /// min corner is `tile_min` with size `cell`. Returns (normal, depth, contact).
    /// Implementations may keep this in `world` if preferred; this signature is a guide.
    fn aabb_tile_pushout(c: Vec2, he: Vec2, tile_min: Vec2, cell: f32) -> (Vec2, f32, Vec2);

    /// Axis-aligned push-out of a circle from a solid tile cell.
    fn circle_tile_pushout(c: Vec2, r: f32, tile_min: Vec2, cell: f32) -> (Vec2, f32, Vec2);
}

// -----------------------------------------------------------------------------
// Semantics (concise; implementers must adhere)
// -----------------------------------------------------------------------------

/*
Tile DDA raycast:
- Use classic voxel/grid DDA stepping. Maintain tMaxX/Y and tDeltaX/Y.
- On entering a solid cell that passes mutual consent against `mask`, compute boundary hit:
  - normal = +/-X if crossing vertical boundary; +/-Y for horizontal.
  - contact = intersection point on that boundary; toi in [0, max_t].
  - hint.safe_pos = Some(origin + dir * (toi - eps)), eps = max(tile_eps, 1e-6).
  - hint.start_embedded = false; hint.fully_embedded = false.
- If ray origin is inside a consenting solid cell, you may return None (no exit defined)
  but `query_*_all` should reveal embedding; events can be produced via overlap path.

AABB sweep vs tiles:
- Treat motion p(t) = p0 + v*t, t∈[0,1]. Maintain next boundary times (tx,ty) using voxel traversal
  for the AABB’s min corner (or both corners; choose a consistent scheme).
- At each axis crossing, test only the *entering stripe* of cells touched by the AABB face at current t.
- First consenting solid → impact:
  - normal = ±X if tx<ty, else ±Y (tie-breaker is impl-defined but stable).
  - contact = face point at impact; toi = t at impact; hint.safe_pos as above.
- Start-embedded handling:
  - If AABB overlaps any consenting solid at t=0, set hint.start_embedded=true.
  - Attempt axis push-out to nearest empty along ±X/±Y (scan contiguous solids until empty).
  - If success: set hint.safe_pos to pushed position; fully_embedded=false.
  - If no axis frees you: set fully_embedded=true; safe_pos=None.
- Circle sweep via Minkowski:
  - Inflate tiles by radius r (equivalently, sweep AABB with he=(r,r)); follow same rules.

Unified ray/queries:
- raycast_all: compute collider-only hit (existing) and tile-only hit; return closer toi.
- query_*_all: union colliders (existing) and tiles (cells overlapped by shape); return BodyRef + keys.

Events:
- generate_events must include collider↔collider (unchanged) and collider↔tile pairs via tile sweeps/overlaps.
- Respect `require_mutual_consent`. At most one event per collider↔tile per frame; sweeps preferred over overlaps when moving.
- Populate Overlap/Sweep with `hint` as defined.

Consent:
- When `require_mutual_consent=true` (recommended), A vs Tile hits occur iff:
    A.collides_with & Tile.layer != 0 && A.exclude & Tile.layer == 0
 && Tile.collides_with & A.layer != 0 && Tile.exclude & A.layer == 0.
- When false, one-sided consent is sufficient (for engines that prefer that).

Numerics:
- Use `tile_eps = max(cfg.tile_eps, 1e-6)` for safe_pos backoff.
- Tolerate tiny negatives in toi due to fp (clamp to [0,1]).
*/

// -----------------------------------------------------------------------------
// Minimal Usage Snippet (reference only; not compiled here)
// -----------------------------------------------------------------------------

/*
let map = world.attach_tilemap(TileMapDesc {
    origin: Vec2::new(0.0, 0.0),
    cell: 32.0,
    width: 128, height: 128,
    solids: &level_bits, // 0/1 bytes
    mask: LayerMask::simple(1<<2, 1<<1),      // tiles on layer 2, collide with movers(1)
    user_key: Some(0xT1LES),
});

world.begin_frame();
let player = world.push_aabb(
    Vec2::new(50.0, 50.0),
    Vec2::new(14.0, 18.0),
    Vec2::new(220.0, 0.0),
    LayerMask::simple(1<<1, 1<<2),
    Some(0xPLAYER),
);
world.end_frame();

// Unified ray
if let Some((who, hit, _key)) = world.raycast_all(
    Vec2::new(10.0,10.0),
    Vec2::new(1.0,0.2).normalize(),
    LayerMask::simple(!0,!0),
    2000.0
) {
    if let Some(p) = hit.hint.safe_pos {
        // block at p if this is a “hard” collision
    }
}

// Events include tiles
world.generate_events();
for e in world.drain_events() {
    if let (EventKind::Sweep, BodyRef::Tile(tref)) = (e.kind, e.b) {
        let h = e.sweep.unwrap();
        if h.hint.fully_embedded {
            // teleport / resolve specially
        }
    }
}
*/

// -----------------------------------------------------------------------------
// Test Contract (must-pass; summary)
// -----------------------------------------------------------------------------

/*
Unit:
- Ray DDA: horizontal/vertical/diagonal; correct first cell; toi monotone with max_t.
- Masking: require_mutual_consent gates hits as specified.
- AABB sweep: hits on vertical/horizontal walls; correct normal; safe_pos outside by eps.
- Start-embedded: push-out finds nearest axis cell when possible; boxed-in => fully_embedded=true.
- Circle sweep (Minkowski): matches AABB(he=r) within epsilon.
- query_*_all: exact overlapped cell set (≤4 for AABB/circle).
- Resolution: applying safe_pos (+ tiny normal nudge) yields no overlap.

Property (proptest):
- Ray monotonicity: increasing max_t doesn’t remove existing hit.
- Safe-pos invariant: if safe_pos.is_some(), query_*_all at safe_pos reports no tile hit.
- Relative-velocity equivalence (tile variant): AABB vs tiles sweep toi matches analytic axis crossing within tolerance.

Benches (Criterion):
- tile_raycast_throughput: rays/sec on sparse vs dense maps.
- tile_sweep_throughput: sweeps/sec for random AABB moves.
- end_to_end: ~10k movers + 256x256 tiles; begin→push→end→generate throughput.
*/
```
